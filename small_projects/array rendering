import pygame
import math
import numpy as np

# Initialize Pygame
pygame.init()

# Screen dimensions
WIDTH, HEIGHT = 800, 600
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("3D Rendering Engine")

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

# Is the user creating a custom shape?
making = False
# Show edges?
show_edges = False
# Allows for the creation of custom shapes
class HumanMadeShape:
    # Initialize vertices, edges, and faces
    def __init__(self):
        print("Keybinds:")
        print("(Once slected you can move virtces)")
        print("b: Add a vertex ")
        print("n: Add an edge")
        print("m: Add a face")
        print(",: Set pivot point")
        print(".: Remove something")
        print("/: Turn edge shows on/off")
        self.vertices = []
        self.edges = []
        self.faces = []
        self.pivot = (0, 0, 0)
        if input("Do you already have a work in progress shape? (y/n): ") == "y":
            print("Format for vertices: [(x1, y1, z1), (x2, y2, z2), ...]")
            self.vertices = eval(input("Enter the vertices of the shape: "))
            print("Format for edges: [(start_vertex1, end_vertex1), (start_vertex2, end_vertex2), ...]")
            self.edges = eval(input("Enter the edges of the shape: "))
            print("Format for faces: [((vertex1, vertex2, vertex3, ..., vertexn), color1), ...]")
            self.faces = eval(input("Enter the faces of the shape: "))
            print("Format for pivot: (x, y, z)")
            self.pivot = eval(input("Enter the pivot point of the shape: "))

    def add_new_vertex(self, x, y, z):
        self.vertices.append((x, y, z))

    def add_new_edge(self, start_vertex, end_vertex):
        self.edges.append((start_vertex, end_vertex))

    def add_new_face(self, vertex_indices, color):
        self.faces.append((vertex_indices, color))

    def remove_previous_vertex(self, vertex_index):
        self.vertices.pop(vertex_index)

    def remove_previous_edge(self, edge_index):
        self.edges.pop(edge_index)  

    def remove_previous_face(self, face_index):
        self.faces.pop(face_index)

    def set_pivot(self, x, y, z):
        self.pivot = (x, y, z)
        

#shape selection / creation
if input("Do you want to use the default shape? (y/n): ") == "y":
    cube = True  # Set to False to render a different shape
    if cube:
        # Cube vertices
        # (x, y, z)
        vertices = [
            (-1, -1, -1),
            (1, -1, -1),
            (1, 1, -1),
            (-1, 1, -1),
            (-1, -1, 1),
            (1, -1, 1),
            (1, 1, 1),
            (-1, 1, 1)
        ]

        # Pivot point
        pivot = (0, 0, 0)  # Pivot point
        
        # Cube edges
        # (start_vertex, end_vertex)
        edges = [
            (0, 1), (1, 2), (2, 3), (3, 0),
            (4, 5), (5, 6), (6, 7), (7, 4),
            (0, 4), (1, 5), (2, 6), (3, 7)
        ]
        
        # Cube faces
        # ((vertex1, vertex2, vertex3, vertex4), color)
        faces = [
            ((0, 1, 2, 3), (255, 0, 0)),
            ((4, 5, 6, 7), (0, 255, 0)),
            ((0, 1, 5, 4), (0, 0, 255)),
            ((2, 3, 7, 6), (255, 255, 0)),
            ((0, 3, 7, 4), (255, 0, 255)),
            ((1, 2, 6, 5), (0, 255, 255))
        ]
    else:
        # Shape vertices
        # (x, y, z)
        vertices = [
            (1, 1, -1),
            (3, 1, 1),
            (-1, 1, 1),
            (1, 1, 3),
            (1, 3, 1),
            (1, -1, 1)
        ]
        # Pivot point
        pivot = (1, 1, 1)  # Pivot point
        # Shape edges
        # (start_vertex, end_vertex)
        edges = [
            (0,1), (1,3), (3,2), (2,0),
            (0,4), (1,4), (3,4), (2,4),
            (0,5), (1,5), (3,5), (2,5)
        ]

        # Shape faces
        # ((vertex1, vertex2, vertex3), color)
        faces = [
            ((0, 1, 4), (255, 0, 0)),
            ((1, 3, 4), (0, 255, 0)),
            ((3, 2, 4), (0, 0, 255)),
            ((2, 0, 4), (255, 255, 0)),
            ((0, 1, 5), (255, 0, 255)),
            ((1, 3, 5), (0, 255, 255)),
            ((3, 2, 5), (255, 255, 255)),
            ((2, 0, 5), (155, 0, 0)),
        ]
else:
    making = True
    working_shape = HumanMadeShape()
    vertices = working_shape.vertices
    edges = working_shape.edges
    faces = working_shape.faces
    pivot = working_shape.pivot
    

def project(x, y, z, scale, distance):
    factor = scale / (distance + z)
    x = x * factor + WIDTH // 2
    y = -y * factor + HEIGHT // 2
    return int(x), int(y)

# Draw faces and edges (edges are turned off by default because that overlaps the faces)
def draw_faces_and_edges(transformed_vertices):
    # Calculate the average depth of each face
    face_depths = []
    for face in faces:
        vertices_indices, color = face
        avg_depth = np.mean([transformed_vertices[i][2] for i in vertices_indices])
        face_depths.append((avg_depth, face))
    
    # Sort faces by depth (furthest to closest)
    face_depths.sort(reverse=True, key=lambda x: x[0])
    
    # Draw faces in sorted order
    for i, face in face_depths:
        vertices_indices, color = face
        points = [project(*transformed_vertices[i], 400, 4) for i in vertices_indices]
        pygame.draw.polygon(screen, color, points)

    # Calculate the average depth of each edge
    edge_depths = []
    for edge in edges:
        avg_depth = np.mean([transformed_vertices[i][2] for i in edge])
        edge_depths.append((avg_depth, edge))
    
    # Sort edges by depth (furthest to closest)
    edge_depths.sort(reverse=True, key=lambda x: x[0])
    
    # Draw edges in sorted order
    for _, edge in edge_depths:
        points = []
        for vertex in edge:
            x, y, z = transformed_vertices[vertex]
            points.append(project(x, y, z, 400, 4))
        if show_edges:
            pygame.draw.line(screen, WHITE, points[0], points[1], 1)

def main():
    clock = pygame.time.Clock()
    angle_x = 0
    angle_y = 0
    angle_z = 0
    pos_x = 0
    pos_y = 0
    pos_z = 0
    running = True

    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    running = False

        keys = pygame.key.get_pressed()
        if keys[pygame.K_LEFT]:
            angle_y -= 0.1
        if keys[pygame.K_RIGHT]:
            angle_y += 0.1
        if keys[pygame.K_UP]:
            angle_x -= 0.1
        if keys[pygame.K_DOWN]:
            angle_x += 0.1
        if keys[pygame.K_e]:
            angle_z -= 0.1
        if keys[pygame.K_q]:
            angle_z += 0.1
        if keys[pygame.K_s]:
            pos_z -= 0.1
        if keys[pygame.K_w]:
            pos_z += 0.1
        if keys[pygame.K_a]:
            pos_x -= 0.1
        if keys[pygame.K_d]:
            pos_x += 0.1
        if keys[pygame.K_SPACE]:
            pos_y += 0.1
        if keys[pygame.K_c]:
            pos_y -= 0.1
        if making:
            if keys[pygame.K_m]:
                try:
                    if input("Do you want to add a new face? (y/n): ") == "y":
                        print("Enter the vertices of the face you want to add: ")
                        while True:
                            print("Format for color: (r, g, b) up to 255")
                            temp_color = eval(input())
                            screen.fill(temp_color)
                            this_color = input("Is this the color you want? (y/n): ")
                            if this_color == "y":
                                break
                        print("Format for vertex: (vertex1, vertex2, vertex3, ..., vertexn)")
                        working_shape.add_new_face(eval(input()), temp_color)
                except Exception as e:
                    print(f"Error: {e}")
            if keys[pygame.K_n]:
                try:
                    if input("Do you want to add a new edge? (y/n): ") == "y":
                        print("Enter the vertice # of the edge you want to add: ")
                        temp_vertices = ""
                        for i in range(len(vertices)):
                            temp_vertices += (str(i) + ": " + str(vertices[i]) + " ")
                        print("Here are the vertices you have: \n" + str(temp_vertices))
                        print("Format: (vertex1, vertex2)")
                        working_shape.add_new_edge(*eval(input()))
                except Exception as e:
                    print(f"Error: {e}")
            if keys[pygame.K_b]:
                try:
                    if input("Do you want to add a new vertex? (y/n): ") == "y":
                        print("Enter the vertex you want to add: ")
                        print("Format: (x, y, z)")
                        working_shape.add_new_vertex(*eval(input()))
                except Exception as e:
                    print(f"Error: {e}")
            if keys[pygame.K_COMMA]:
                try:
                    print("Here are the vertices you have: \n" + str(vertices))
                    print("Enter the pivot point of the shape: ")
                    print("Format: (x, y, z)")
                    working_shape.set_pivot(*eval(input()))
                except Exception as e:
                    print(f"Error: {e}")
            if keys[pygame.K_PERIOD]:
                try:
                    if input("Do you want to remove something? (y/n): ") == "y":
                        what_to_remove = input("What do you want to remove? (vertex (v), edge (e), face (f)): ")
                        if what_to_remove == "v" or what_to_remove == "vertex":
                            temp_vertices = ""
                            for i in range(len(vertices)):
                                temp_vertices += (str(i) + ": " + str(vertices[i]) + " ")
                            print("Enter the index of the vertex you want to remove: ")
                            print("Here are the vertices you have: \n" + str(temp_vertices))
                            working_shape.remove_previous_vertex(int(input()))
                        elif what_to_remove == "e" or what_to_remove == "edge":
                            temp_edges = ""
                            for i in range(len(edges)):
                                temp_edges += (str(i) + ": " + str(edges[i]) + " ")
                            print("Enter the index of the edge you want to remove: ")
                            print("Here are the edges you have: \n" + str(temp_edges))
                            working_shape.remove_previous_edge(int(input()))
                        elif what_to_remove == "f" or what_to_remove == "face":
                            temp_faces = ""
                            for i in range(len(faces)):
                                temp_faces += (str(i) + ": " + str(faces[i]) + " ")
                            print("Enter the index of the face you want to remove: ")
                            print("Here are the faces you have: \n" + str(temp_faces))
                            working_shape.remove_previous_face(int(input()))
                except Exception as e:
                    print(f"Error: {e}")
            if keys[pygame.K_SLASH]:
                global show_edges
                show_edges = not show_edges
                print("Edges are now " + ("on" if show_edges else "off"))

        
        screen.fill(BLACK)
        #pygame.draw.rect(screen, (0, 255, 0), (0, HEIGHT // 2, WIDTH, HEIGHT // 2))
        # Rotate cube
        cos_angle_x = math.cos(angle_x)
        sin_angle_x = math.sin(angle_x)
        cos_angle_y = math.cos(angle_y)
        sin_angle_y = math.sin(angle_y)
        cos_angle_z = math.cos(angle_z)
        sin_angle_z = math.sin(angle_z)

        transformed_vertices = []
        for x, y, z in vertices:
            # Translate to pivot
            x -= pivot[0]
            y -= pivot[1]
            z -= pivot[2]
            # Rotate around x-axis
            y, z = y * cos_angle_x - z * sin_angle_x, z * cos_angle_x + y * sin_angle_x
            # Rotate around y-axis
            x, z = x * cos_angle_y - z * sin_angle_y, z * cos_angle_y + x * sin_angle_y
            # Rotate around z-axis
            x, y = x * cos_angle_z - y * sin_angle_z, y * cos_angle_z + x * sin_angle_z
            # Translate back from pivot
            x += pivot[0] + pos_x
            y += pivot[1] + pos_y
            z += pivot[2] + pos_z
            transformed_vertices.append((x, y, z))

        # Draw faces
        draw_faces_and_edges(transformed_vertices)

        pygame.display.flip()
        clock.tick(60)

    pygame.quit()

if __name__ == "__main__":
    main()
